# -*- coding: utf-8 -*-
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models import db, Pago, Orden, Auto, Cliente
from datetime import datetime
from sqlalchemy import text

payments_bp = Blueprint('payments', __name__, url_prefix='/payments')

@payments_bp.route('/', methods=['POST'])
@jwt_required()
def create_payment():
    """
    Crea un nuevo pago para una orden.
    Valida que la orden este finalizada y que el monto no exceda el saldo pendiente.
    """
    try:
        data = request.get_json()
        
        # Validaciones basicas
        if not data:
            return jsonify({'msg': 'No se recibieron datos'}), 400
        
        orden_id = data.get('orden_id')
        monto = data.get('monto')
        metodo_pago = data.get('metodo_pago')
        referencia = data.get('referencia', '')
        
        if not all([orden_id, monto, metodo_pago]):
            return jsonify({'msg': 'Faltan campos requeridos: orden_id, monto, metodo_pago'}), 400
        
        # Validar que el monto sea positivo
        try:
            monto = float(monto)
            if monto <= 0:
                return jsonify({'msg': 'El monto debe ser mayor a 0'}), 400
        except (ValueError, TypeError):
            return jsonify({'msg': 'Monto invalido'}), 400
        
        # Buscar la orden
        work_order = Orden.query.get(orden_id)
        if not work_order:
            return jsonify({'msg': 'Orden no encontrada'}), 404
        
        # VALIDACION CRITICA: Verificar que la orden este finalizada
        estado_orden = work_order.estado.nombre_estado if work_order.estado else None
        if estado_orden not in ['Finalizado', 'Entregado']:
            return jsonify({
                "msg": "No se puede registrar un pago para una orden que no ha sido finalizada",
                "estado_actual": estado_orden,
                "estados_permitidos": ["Finalizado", "Entregado"]
            }), 400
        
        # Validar que el monto no exceda el saldo pendiente
        saldo_pendiente = work_order.calcular_saldo_pendiente()
        if float(monto) > saldo_pendiente + 0.01:  # Tolerancia para decimales
            return jsonify({
                "msg": "El monto del pago excede el saldo pendiente",
                "monto_solicitado": float(monto),
                "saldo_pendiente": saldo_pendiente,
                "total_orden": work_order.total_estimado
            }), 400
        
        # Crear el pago usando SQL directo
        usuario_id = get_jwt_identity()
        fecha_pago = datetime.now()
        
        query = text("""
            INSERT INTO pagos (orden_id, monto, metodo_pago, referencia, fecha_pago, usuario_id, activo)
            VALUES (:orden_id, :monto, :metodo_pago, :referencia, :fecha_pago, :usuario_id, 1)
        """)
        
        result = db.session.execute(query, {
            'orden_id': orden_id,
            'monto': monto,
            'metodo_pago': metodo_pago,
            'referencia': referencia,
            'fecha_pago': fecha_pago,
            'usuario_id': usuario_id
        })
        
        db.session.commit()
        payment_id = result.lastrowid
        
        # Calcular balance actualizado
        balance = {
            'total_orden': work_order.total_estimado,
            'total_pagado': work_order.calcular_total_pagado(),
            'saldo_pendiente': work_order.calcular_saldo_pendiente(),
            'pagado_completamente': work_order.esta_pagado_completamente()
        }
        
        return jsonify({
            'msg': 'Pago registrado exitosamente',
            'payment': {
                'id': payment_id,
                'orden_id': orden_id,
                'monto': monto,
                'metodo_pago': metodo_pago,
                'referencia': referencia,
                'fecha_pago': fecha_pago.isoformat()
            },
            'balance': balance
        }), 201
        
    except Exception as e:
        db.session.rollback()
        print(f"Error al crear pago: {str(e)}")
        return jsonify({'msg': 'Error al crear el pago', 'error': str(e)}), 500


@payments_bp.route('/history', methods=['GET'])
@jwt_required()
def get_payment_history():
    """
    Obtiene el historial de pagos con informacion detallada.
    Incluye: cliente_nombre, placa del vehiculo, y detalles del pago.
    """
    try:
        # Parametros opcionales para filtrado
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        per_page = int(request.args.get('per_page', 1000))
        
        # Query con JOINS para obtener informacion completa
        query = db.session.query(
            Pago.id,
            Pago.orden_id,
            Pago.monto,
            Pago.metodo_pago,
            Pago.referencia,
            Pago.fecha_pago,
            Cliente.nombre.label('cliente_nombre'),
            Cliente.apellido.label('cliente_apellido'),
            Auto.placa
        ).join(
            Orden, Pago.orden_id == Orden.id
        ).join(
            Auto, Orden.auto_id == Auto.id
        ).join(
            Cliente, Auto.cliente_id == Cliente.id
        ).filter(
            Pago.activo == True
        )
        
        # Aplicar filtros de fecha si existen
        if fecha_inicio:
            query = query.filter(Pago.fecha_pago >= fecha_inicio)
        if fecha_fin:
            query = query.filter(Pago.fecha_pago <= fecha_fin)
        
        # Ordenar por fecha mas reciente primero
        query = query.order_by(Pago.fecha_pago.desc())
        
        # Limitar resultados
        payments = query.limit(per_page).all()
        
        # Formatear respuesta
        result = []
        for p in payments:
            result.append({
                'id': p.id,
                'orden_id': p.orden_id,
                'monto': float(p.monto),
                'metodo_pago': p.metodo_pago,
                'referencia': p.referencia or '',
                'fecha_pago': p.fecha_pago.isoformat() if p.fecha_pago else None,
                'cliente_nombre': f"{p.cliente_nombre} {p.cliente_apellido or ''}".strip(),
                'placa': p.placa
            })
        
        return jsonify(result), 200
        
    except Exception as e:
        print(f"Error al obtener historial de pagos: {str(e)}")
        return jsonify({'msg': 'Error al obtener historial', 'error': str(e)}), 500


@payments_bp.route('/<int:payment_id>', methods=['GET'])
@jwt_required()
def get_payment(payment_id):
    """
    Obtiene los detalles de un pago especifico.
    """
    try:
        # Query con informacion detallada
        query = text("""
            SELECT 
                p.id,
                p.orden_id,
                p.monto,
                p.metodo_pago,
                p.referencia,
                p.fecha_pago,
                c.nombre as cliente_nombre,
                c.apellido as cliente_apellido,
                a.placa,
                o.total_estimado
            FROM pagos p
            JOIN ordenes o ON p.orden_id = o.id
            JOIN autos a ON o.auto_id = a.id
            JOIN clientes c ON a.cliente_id = c.id
            WHERE p.id = :payment_id AND p.activo = 1
        """)
        
        result = db.session.execute(query, {'payment_id': payment_id}).fetchone()
        
        if not result:
            return jsonify({'msg': 'Pago no encontrado'}), 404
        
        payment_data = {
            'id': result.id,
            'orden_id': result.orden_id,
            'monto': float(result.monto),
            'metodo_pago': result.metodo_pago,
            'referencia': result.referencia or '',
            'fecha_pago': result.fecha_pago.isoformat() if result.fecha_pago else None,
            'cliente_nombre': f"{result.cliente_nombre} {result.cliente_apellido or ''}".strip(),
            'placa': result.placa,
            'total_orden': float(result.total_estimado) if result.total_estimado else 0
        }
        
        return jsonify(payment_data), 200
        
    except Exception as e:
        print(f"Error al obtener pago: {str(e)}")
        return jsonify({'msg': 'Error al obtener el pago', 'error': str(e)}), 500


@payments_bp.route('/revenue', methods=['GET'])
@jwt_required()
def get_revenue_summary():
    """
    Obtiene el resumen de ingresos: total recaudado y cantidad de pagos.
    """
    try:
        # Parametros opcionales para filtrado
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        # Query base
        query = db.session.query(
            db.func.sum(Pago.monto).label('total_ingresos'),
            db.func.count(Pago.id).label('total_pagos')
        ).filter(Pago.activo == True)
        
        # Aplicar filtros de fecha si existen
        if fecha_inicio:
            query = query.filter(Pago.fecha_pago >= fecha_inicio)
        if fecha_fin:
            query = query.filter(Pago.fecha_pago <= fecha_fin)
        
        result = query.first()
        
        summary = {
            'total_ingresos': float(result.total_ingresos) if result.total_ingresos else 0.0,
            'total_pagos': int(result.total_pagos) if result.total_pagos else 0
        }
        
        return jsonify(summary), 200
        
    except Exception as e:
        print(f"Error al obtener resumen de ingresos: {str(e)}")
        return jsonify({'msg': 'Error al obtener resumen', 'error': str(e)}), 500


@payments_bp.route('/order/<int:orden_id>/balance', methods=['GET'])
@jwt_required()
def get_order_payment_balance(orden_id):
    """
    Obtiene el balance de pagos para una orden especifica.
    Retorna: total_estimado, total_pagado, saldo_pendiente, pagado_completamente, lista de pagos.
    """
    try:
        # Buscar la orden
        orden = Orden.query.get(orden_id)
        if not orden:
            return jsonify({'msg': 'Orden no encontrada'}), 404
        
        # Obtener pagos de la orden
        pagos = Pago.query.filter_by(orden_id=orden_id, activo=True).all()
        
        # Formatear lista de pagos
        pagos_list = []
        for pago in pagos:
            pagos_list.append({
                'id': pago.id,
                'monto': float(pago.monto),
                'metodo_pago': pago.metodo_pago,
                'referencia': pago.referencia or '',
                'fecha_pago': pago.fecha_pago.isoformat() if pago.fecha_pago else None
            })
        
        # Calcular balance
        balance = {
            'orden_id': orden_id,
            'total_estimado': float(orden.total_estimado) if orden.total_estimado else 0.0,
            'total_pagado': orden.calcular_total_pagado(),
            'saldo_pendiente': orden.calcular_saldo_pendiente(),
            'pagado_completamente': orden.esta_pagado_completamente(),
            'estado_orden': orden.estado.nombre_estado if orden.estado else None,
            'pagos': pagos_list
        }
        
        return jsonify(balance), 200
        
    except Exception as e:
        print(f"Error al obtener balance de pagos: {str(e)}")
        return jsonify({'msg': 'Error al obtener balance', 'error': str(e)}), 500
